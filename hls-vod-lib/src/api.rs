use crate::error::Result;
use crate::index::scanner;
use crate::playlist::{generate_master_playlist, variant};
use crate::segment::generator;
use crate::types::StreamIndex;
use ffmpeg_next as ffmpeg;
use std::path::Path;

pub use crate::cache::{cache_stats, init_cache, CacheConfig, CacheStats};

/// Core metadata for a loaded media file, used for generating playlists and segments.
/// Generated by parsing a given file with `parse_file`.
#[derive(Debug, Clone)]
pub struct MediaInfo {
    /// Total file size in bytes
    pub file_size: u64,
    /// Total duration of the media in seconds
    pub duration_secs: f64,
    /// The fundamental timeline for all video and audio timing in this file
    pub video_timebase: ffmpeg::Rational,
    /// Tracks available in this media (video/audio/subtitle)
    pub tracks: Vec<TrackInfo>,
    /// The underlying stream index generated from demuxing
    pub index: StreamIndex,
    /// Whether generated segments for this media should be aggressively cached and LRU bumped
    pub cache_enabled: bool,
}

static STREAMS_BY_ID: std::sync::OnceLock<dashmap::DashMap<String, std::sync::Arc<MediaInfo>>> =
    std::sync::OnceLock::new();

/// Retrieve a tracked media stream by its generated stream ID
pub(crate) fn get_stream_by_id(stream_id: &str) -> Option<std::sync::Arc<MediaInfo>> {
    STREAMS_BY_ID
        .get_or_init(dashmap::DashMap::new)
        .get(stream_id)
        .map(|r| r.value().clone())
}

/// Remove a tracked media stream by its generated stream ID
pub(crate) fn remove_stream_by_id(stream_id: &str) {
    if let Some(_media) = STREAMS_BY_ID
        .get_or_init(dashmap::DashMap::new)
        .remove(stream_id)
    {
        if let Some(c) = crate::cache::global_cache() {
            c.remove_stream(stream_id);
        }
    }
}

/// Active stream metadata
#[derive(serde::Serialize, Clone, Debug)]
pub struct ActiveStreamInfo {
    pub stream_id: String,
    pub path: String,
    pub duration: f64,
}

/// Fetch a list of active streams
pub fn active_streams() -> Vec<ActiveStreamInfo> {
    STREAMS_BY_ID
        .get_or_init(dashmap::DashMap::new)
        .iter()
        .map(|r| ActiveStreamInfo {
            stream_id: r.value().index.stream_id.clone(),
            path: r.value().index.source_path.to_string_lossy().to_string(),
            duration: r.value().index.duration_secs,
        })
        .collect()
}

/// Remove expired streams from tracking and cache
pub fn cleanup_expired_streams() -> usize {
    const STREAM_TIMEOUT_SECS: u64 = 600; // 10 minutes

    let mut streams_to_remove = Vec::new();

    for entry in STREAMS_BY_ID.get_or_init(dashmap::DashMap::new).iter() {
        if entry.value().index.time_since_last_access() > STREAM_TIMEOUT_SECS {
            streams_to_remove.push(entry.key().clone());
        }
    }

    let mut count = 0;
    for stream_id in streams_to_remove {
        remove_stream_by_id(&stream_id);
        count += 1;
    }

    count
}

#[cfg(test)]
pub fn register_test_stream(media: std::sync::Arc<MediaInfo>) {
    STREAMS_BY_ID
        .get_or_init(dashmap::DashMap::new)
        .insert(media.index.stream_id.clone(), media.clone());
}

/// Description of the media track available to the client.
#[derive(Debug, Clone)]
pub struct TrackInfo {
    /// The unique identifier of this track within the media (e.g. `v/0`, `a/1`)
    pub id: String,
    /// The specific type and type-dependent attributes of the track
    pub track_type: TrackType,
    /// Identifier for the codec used (e.g. "avc1.42001e", "mp4a.40.2")
    pub codec_id: String,
    /// Track language code if specified from the source metadata
    pub language: Option<String>,
    /// Track bitrate in bits per second if explicitly specified
    pub bitrate: Option<u64>,
    /// The codec to which this track should be transcoded
    pub transcode_to: Option<String>,
}

/// Categorization of a track type
#[derive(Debug, Clone, PartialEq)]
pub enum TrackType {
    /// A video track with an explicit width and height
    Video { width: u32, height: u32 },
    /// An audio track with explicit sample rate and number of channels
    Audio { channels: u16, sample_rate: u32 },
    /// A subtitle track matching a specific text format (e.g., "WebVtt", "SubRip")
    Subtitle { format: String },
}

impl MediaInfo {
    /// Parse a media file quickly without segment indexing or caching.
    /// Useful for getting basic track info and duration.
    pub fn parse(path: &Path) -> Result<MediaInfo> {
        let options = scanner::IndexOptions {
            segment_duration_secs: 4.0,
            index_segments: false,
        };
        let index = scanner::scan_file_with_options(path, &options)?;
        Ok(Self::build_media_info(path, index, false))
    }

    /// Open a media file, performing full segment indexing.
    /// Uses `stream_id` for caching if provided, otherwise generates a new one.
    pub fn open(path: &Path, stream_id: Option<String>) -> Result<std::sync::Arc<MediaInfo>> {
        if let Some(id) = &stream_id {
            if let Some(media) = get_stream_by_id(id) {
                media.index.touch();
                return Ok(media);
            }
        }

        let options = scanner::IndexOptions {
            segment_duration_secs: 4.0,
            index_segments: true,
        };
        let mut index = scanner::scan_file_with_options(path, &options)?;

        if let Some(id) = stream_id {
            index.stream_id = id;
        }

        let media = std::sync::Arc::new(Self::build_media_info(path, index, true));

        STREAMS_BY_ID
            .get_or_init(dashmap::DashMap::new)
            .insert(media.index.stream_id.clone(), media.clone());

        Ok(media)
    }

    fn build_media_info(path: &Path, index: StreamIndex, cache: bool) -> Self {
        let mut tracks = Vec::new();

        // Video tracks
        for v in &index.video_streams {
            tracks.push(TrackInfo {
                id: format!("v/{}", v.stream_index),
                track_type: TrackType::Video {
                    width: v.width,
                    height: v.height,
                },
                codec_id: format!("{:?}", v.codec_id),
                language: v.language.clone(),
                bitrate: Some(v.bitrate),
                transcode_to: None,
            });
        }

        // Audio tracks
        for a in &index.audio_streams {
            tracks.push(TrackInfo {
                id: format!("a/{}", a.stream_index),
                track_type: TrackType::Audio {
                    channels: a.channels,
                    sample_rate: a.sample_rate,
                },
                codec_id: format!("{:?}", a.codec_id),
                language: a.language.clone(),
                bitrate: Some(a.bitrate),
                transcode_to: None,
            });
        }

        // Subtitle tracks
        for s in &index.subtitle_streams {
            tracks.push(TrackInfo {
                id: format!("s/{}", s.stream_index),
                track_type: TrackType::Subtitle {
                    format: format!("{:?}", s.format),
                },
                codec_id: format!("{:?}", s.codec_id),
                language: s.language.clone(),
                bitrate: None,
                transcode_to: None,
            });
        }

        let file_size = std::fs::metadata(path).map(|m| m.len()).unwrap_or(0);

        Self {
            file_size,
            duration_secs: index.duration_secs,
            video_timebase: index.video_timebase,
            tracks,
            index,
            cache_enabled: cache,
        }
    }

    /// Generate the master playlist (m3u8).
    /// Returns a multi-variant HLS playlist that directs clients to specific audio/video tracks.
    pub fn generate_main_playlist(&self, prefix: &str) -> Result<String> {
        Ok(generate_master_playlist(&self.index, prefix))
    }

    /// Generate a variant track playlist.
    /// Returns a media playlist that lists available segments for the track specified by `playlist_id`.
    pub fn generate_track_playlist(&self, playlist_id: &str) -> Result<String> {
        if playlist_id == "v/media.m3u8" {
            return Ok(variant::generate_video_playlist(&self.index));
        }

        if let Some(caps) = regex::Regex::new(r"a/(\d+)(?:-aac)?(?:/media)?\.m3u8")
            .unwrap()
            .captures(playlist_id)
        {
            let id_idx: usize = caps[1]
                .parse()
                .map_err(|_| crate::error::HlsError::Muxing("Invalid audio ID".to_string()))?;
            let force_aac = playlist_id.contains("-aac");
            return Ok(variant::generate_audio_playlist(
                &self.index,
                id_idx,
                force_aac,
            ));
        }

        if let Some(caps) = regex::Regex::new(r"s/(\d+)(?:/media)?\.m3u8")
            .unwrap()
            .captures(playlist_id)
        {
            let id_idx: usize = caps[1]
                .parse()
                .map_err(|_| crate::error::HlsError::Muxing("Invalid subtitle ID".to_string()))?;
            return Ok(variant::generate_subtitle_playlist(&self.index, id_idx));
        }

        Err(crate::error::HlsError::Muxing(format!(
            "Invalid playlist ID: {}",
            playlist_id
        )))
    }

    /// Generate a media segment.
    /// Uses the provided `segment_id` (e.g. `v/init.mp4` or `a/1/0.m4s`) to determine whether an initialization segment
    /// or a media segment should be remuxed/transcoded and returned as bytes.
    pub fn generate_segment(&self, segment_id: &str) -> Result<Vec<u8>> {
        // Handle init segments
        if segment_id == "v/init.mp4" {
            return generator::generate_video_init_segment(&self.index).map(|b| b.to_vec());
        }

        if let Some(caps) = regex::Regex::new(r"a/(\d+)(?:-aac)?/init\.mp4")
            .unwrap()
            .captures(segment_id)
        {
            let id_idx: usize = caps[1]
                .parse()
                .map_err(|_| crate::error::HlsError::Muxing("Invalid audio ID".to_string()))?;
            let force_aac = segment_id.contains("-aac");
            return generator::generate_audio_init_segment(&self.index, id_idx, force_aac)
                .map(|b| b.to_vec());
        }

        // Handle media segments (.m4s, .vtt)
        if let Some(caps) = regex::Regex::new(r"v/(\d+)\.m4s")
            .unwrap()
            .captures(segment_id)
        {
            let seq: usize = caps[1]
                .parse()
                .map_err(|_| crate::error::HlsError::Muxing("Invalid sequence".to_string()))?;

            if let Some(c) = crate::cache::global_cache() {
                if let Some(b) = c.get(&self.index.stream_id, "v", seq, self.cache_enabled) {
                    return Ok(b.to_vec());
                }
            }

            let track_idx = self
                .index
                .video_streams
                .first()
                .map(|v| v.stream_index)
                .unwrap_or(0);
            let buf = generator::generate_video_segment(
                &self.index,
                track_idx,
                seq,
                &self.index.source_path,
            )
            .map(|b| b.to_vec())?;

            if self.cache_enabled {
                if let Some(c) = crate::cache::global_cache() {
                    c.insert(
                        &self.index.stream_id,
                        "v",
                        seq,
                        bytes::Bytes::from(buf.clone()),
                    );
                }
            }
            return Ok(buf);
        }

        if let Some(caps) = regex::Regex::new(r"a/(\d+)(?:-aac)?/(\d+)\.m4s")
            .unwrap()
            .captures(segment_id)
        {
            let id_idx: usize = caps[1]
                .parse()
                .map_err(|_| crate::error::HlsError::Muxing("Invalid audio ID".to_string()))?;
            let seq: usize = caps[2]
                .parse()
                .map_err(|_| crate::error::HlsError::Muxing("Invalid sequence".to_string()))?;
            let force_aac = segment_id.contains("-aac");

            let segment_type = if force_aac {
                format!("a:{}-aac", id_idx)
            } else {
                format!("a:{}", id_idx)
            };

            if let Some(c) = crate::cache::global_cache() {
                if let Some(b) = c.get(
                    &self.index.stream_id,
                    &segment_type,
                    seq,
                    self.cache_enabled,
                ) {
                    return Ok(b.to_vec());
                }
            }

            let buf = generator::generate_audio_segment(
                &self.index,
                id_idx,
                seq,
                &self.index.source_path,
                force_aac,
            )
            .map(|b| b.to_vec())?;

            if self.cache_enabled {
                if let Some(c) = crate::cache::global_cache() {
                    c.insert(
                        &self.index.stream_id,
                        &segment_type,
                        seq,
                        bytes::Bytes::from(buf.clone()),
                    );
                }
            }
            return Ok(buf);
        }

        if let Some(caps) = regex::Regex::new(r"s/(\d+)/(\d+)-(\d+)\.vtt")
            .unwrap()
            .captures(segment_id)
        {
            let id_idx: usize = caps[1]
                .parse()
                .map_err(|_| crate::error::HlsError::Muxing("Invalid subtitle ID".to_string()))?;
            let start_seq: usize = caps[2]
                .parse()
                .map_err(|_| crate::error::HlsError::Muxing("Invalid start seq".to_string()))?;
            let end_seq: usize = caps[3]
                .parse()
                .map_err(|_| crate::error::HlsError::Muxing("Invalid end seq".to_string()))?;

            // Subtitles spans multiple sequences in formatting, we use start_seq as cache sequence map
            let segment_type = format!("s:{}", id_idx);

            if let Some(c) = crate::cache::global_cache() {
                if let Some(b) = c.get(
                    &self.index.stream_id,
                    &segment_type,
                    start_seq,
                    self.cache_enabled,
                ) {
                    return Ok(b.to_vec());
                }
            }

            let buf = generator::generate_subtitle_segment(
                &self.index,
                id_idx,
                start_seq,
                end_seq,
                &self.index.source_path,
            )
            .map(|b| b.to_vec())?;

            if self.cache_enabled {
                if let Some(c) = crate::cache::global_cache() {
                    c.insert(
                        &self.index.stream_id,
                        &segment_type,
                        start_seq,
                        bytes::Bytes::from(buf.clone()),
                    );
                }
            }
            return Ok(buf);
        }

        Err(crate::error::HlsError::Muxing(format!(
            "Invalid segment ID: {}",
            segment_id
        )))
    }
}
