use crate::error::Result;
use crate::index::scanner;
use crate::segment;
use crate::types::StreamIndex;
use ffmpeg_next as ffmpeg;
use std::path::Path;

pub use crate::segment::cache::{
    cache_stats as segment_cache_stats, init_cache as init_segment_cache, SegmentCacheConfig,
    SegmentCacheStats,
};

/// Core metadata for a loaded media file, used for generating playlists and segments.
/// Generated by parsing a given file with `parse_file`.
#[derive(Debug, Clone)]
pub struct MediaInfo {
    /// Total file size in bytes
    pub file_size: u64,
    /// Total duration of the media in seconds
    pub duration_secs: f64,
    /// The fundamental timeline for all video and audio timing in this file
    pub video_timebase: ffmpeg::Rational,
    /// Tracks available in this media (video/audio/subtitle)
    pub tracks: Vec<TrackInfo>,
    /// The underlying stream index generated from demuxing
    pub index: StreamIndex,
    /// Whether generated segments for this media should be aggressively cached and LRU bumped
    pub cache_enabled: bool,
}

static STREAMS_BY_ID: std::sync::OnceLock<dashmap::DashMap<String, std::sync::Arc<MediaInfo>>> =
    std::sync::OnceLock::new();

/// Retrieve a tracked media stream by its generated stream ID
pub(crate) fn get_stream_by_id(stream_id: &str) -> Option<std::sync::Arc<MediaInfo>> {
    STREAMS_BY_ID
        .get_or_init(dashmap::DashMap::new)
        .get(stream_id)
        .map(|r| r.value().clone())
}

/// Remove a tracked media stream by its generated stream ID
pub(crate) fn remove_stream_by_id(stream_id: &str) {
    if let Some(_media) = STREAMS_BY_ID
        .get_or_init(dashmap::DashMap::new)
        .remove(stream_id)
    {
        if let Some(c) = segment::cache::get() {
            c.remove_stream(stream_id);
        }
    }
}

/// Active stream metadata
#[derive(serde::Serialize, Clone, Debug)]
pub struct ActiveStreamInfo {
    pub stream_id: String,
    pub path: String,
    pub duration: f64,
}

/// Fetch a list of active streams
pub fn active_streams() -> Vec<ActiveStreamInfo> {
    STREAMS_BY_ID
        .get_or_init(dashmap::DashMap::new)
        .iter()
        .map(|r| ActiveStreamInfo {
            stream_id: r.value().index.stream_id.clone(),
            path: r.value().index.source_path.to_string_lossy().to_string(),
            duration: r.value().index.duration_secs,
        })
        .collect()
}

/// Remove expired streams from tracking and cache
pub fn cleanup_expired_streams() -> usize {
    const STREAM_TIMEOUT_SECS: u64 = 600; // 10 minutes

    let mut streams_to_remove = Vec::new();

    for entry in STREAMS_BY_ID.get_or_init(dashmap::DashMap::new).iter() {
        if entry.value().index.time_since_last_access() > STREAM_TIMEOUT_SECS {
            streams_to_remove.push(entry.key().clone());
        }
    }

    let mut count = 0;
    for stream_id in streams_to_remove {
        remove_stream_by_id(&stream_id);
        count += 1;
    }

    count
}

#[cfg(test)]
pub fn register_test_stream(media: std::sync::Arc<MediaInfo>) {
    STREAMS_BY_ID
        .get_or_init(dashmap::DashMap::new)
        .insert(media.index.stream_id.clone(), media.clone());
}

/// Description of the media track available to the client.
#[derive(Debug, Clone)]
pub struct TrackInfo {
    /// The unique identifier of this track within the media (e.g. `v/0`, `a/1`)
    pub id: String,
    /// The specific type and type-dependent attributes of the track
    pub track_type: TrackType,
    /// Identifier for the codec used (e.g. "avc1.42001e", "mp4a.40.2")
    pub codec_id: String,
    /// Track language code if specified from the source metadata
    pub language: Option<String>,
    /// Track bitrate in bits per second if explicitly specified
    pub bitrate: Option<u64>,
    /// The codec to which this track should be transcoded
    pub transcode_to: Option<String>,
}

/// Categorization of a track type
#[derive(Debug, Clone, PartialEq)]
pub enum TrackType {
    /// A video track with an explicit width and height
    Video { width: u32, height: u32 },
    /// An audio track with explicit sample rate and number of channels
    Audio { channels: u16, sample_rate: u32 },
    /// A subtitle track matching a specific text format (e.g., "WebVtt", "SubRip")
    Subtitle { format: String },
}

impl MediaInfo {
    /// Parse a media file quickly without segment indexing or caching.
    /// Useful for getting basic track info and duration.
    pub fn parse(path: &Path) -> Result<MediaInfo> {
        let options = scanner::IndexOptions {
            segment_duration_secs: 4.0,
            index_segments: false,
        };
        let index = scanner::scan_file_with_options(path, &options)?;
        Ok(Self::build_media_info(path, index, false))
    }

    /// Opens and indexes a media file, caching the result if a stream ID is provided.
    ///
    /// The `codecs` parameter allows filtering the tracks within the media file. Only tracks
    /// matching the provided list of codecs will be retained. If `codecs` is empty, no filtering
    /// is performed.
    ///
    /// The following standard browser-friendly codec names and aliases are supported (case-insensitive):
    /// - **AAC**: `"mp4a.40.2"`, `"aac"`
    /// - **Dolby Digital (AC-3)**: `"ac-3"`, `"ac3"`
    /// - **Dolby Digital Plus (E-AC-3)**: `"ec-3"`, `"eac3"`
    /// - **MP3**: `"mp4a.40.34"`, `"mp3"`
    /// - **Opus**: `"opus"`
    /// - **WebVTT**: `"wvtt"`, `"webvtt"`
    ///
    /// If filtering results in all audio streams being removed, the function will attempt a fallback.
    /// It will restore all audio streams matching the codec of the original primary audio stream, and
    /// schedule them to be transcoded to AAC, provided that `"mp4a.40.2"` or `"aac"` is in the allowed `codecs`.
    pub fn open(
        path: &Path,
        codecs: &[impl AsRef<str>],
        stream_id: Option<String>,
    ) -> Result<std::sync::Arc<MediaInfo>> {
        if let Some(id) = &stream_id {
            if let Some(media) = get_stream_by_id(id) {
                media.index.touch();
                return Ok(media);
            }
        }

        let options = scanner::IndexOptions {
            segment_duration_secs: 4.0,
            index_segments: true,
        };
        let mut index = scanner::scan_file_with_options(path, &options)?;

        if let Some(id) = stream_id {
            index.stream_id = id;
        }

        // Apply codec filtering if codecs are provided
        if !codecs.is_empty() {
            let codec_strs_lower: Vec<String> =
                codecs.iter().map(|c| c.as_ref().to_lowercase()).collect();
            let original_audio_streams = index.audio_streams.clone();

            // Filter audio streams
            index.audio_streams.retain(|a| {
                let browser_codecs = match a.codec_id {
                    ffmpeg::codec::Id::AAC => ["mp4a.40.2", "aac"].as_slice(),
                    ffmpeg::codec::Id::AC3 => ["ac-3", "ac3"].as_slice(),
                    ffmpeg::codec::Id::EAC3 => ["ec-3", "eac3"].as_slice(),
                    ffmpeg::codec::Id::MP3 => ["mp4a.40.34", "mp3"].as_slice(),
                    ffmpeg::codec::Id::OPUS => ["opus"].as_slice(),
                    _ => &[].as_slice(),
                };

                if browser_codecs
                    .iter()
                    .any(|&m| codec_strs_lower.contains(&m.to_string()))
                {
                    return true;
                }

                // Fallback to exact enum match
                let codec_name = format!("{:?}", a.codec_id).to_lowercase();
                codec_strs_lower.contains(&codec_name)
            });

            // Filter subtitle streams (typically 'webvtt' or 'wvtt')
            index.subtitle_streams.retain(|s| {
                let codec_name = match s.codec_id {
                    ffmpeg::codec::Id::WEBVTT => "wvtt",
                    _ => "",
                };
                codec_strs_lower.contains(&codec_name.to_string())
                    || codec_strs_lower.contains(&"webvtt".to_string())
            });

            // If we filtered out all audio streams, but the source had audio streams,
            // we should transcode all audio streams matching the codec of the primary
            // audio stream to AAC, ONLY IF "aac" or "mp4a.40.2" is in the supported codecs list.
            if index.audio_streams.is_empty() && !original_audio_streams.is_empty() {
                if codec_strs_lower.contains(&"aac".to_string())
                    || codec_strs_lower.contains(&"mp4a.40.2".to_string())
                {
                    let fallback_codec = original_audio_streams[0].codec_id;
                    for mut fallback in original_audio_streams
                        .into_iter()
                        .filter(|s| s.codec_id == fallback_codec)
                    {
                        fallback.is_transcoded = true;
                        // Note: We keep the original codec_id in the stream info so the transcoder
                        // knows what to decode FROM. `TrackInfo` will map `is_transcoded` to "aac".
                        index.audio_streams.push(fallback);
                    }
                }
            }
        }

        let media = std::sync::Arc::new(Self::build_media_info(path, index, true));

        STREAMS_BY_ID
            .get_or_init(dashmap::DashMap::new)
            .insert(media.index.stream_id.clone(), media.clone());

        Ok(media)
    }

    fn build_media_info(path: &Path, index: StreamIndex, cache: bool) -> Self {
        let mut tracks = Vec::new();

        // Video tracks
        for v in &index.video_streams {
            tracks.push(TrackInfo {
                id: format!("v/{}", v.stream_index),
                track_type: TrackType::Video {
                    width: v.width,
                    height: v.height,
                },
                codec_id: format!("{:?}", v.codec_id),
                language: v.language.clone(),
                bitrate: Some(v.bitrate),
                transcode_to: None,
            });
        }

        // Audio tracks
        for a in &index.audio_streams {
            let (final_codec, transcode_to) = if a.is_transcoded {
                ("aac".to_string(), Some("aac".to_string()))
            } else {
                (format!("{:?}", a.codec_id), None)
            };

            tracks.push(TrackInfo {
                id: format!("a/{}", a.stream_index),
                track_type: TrackType::Audio {
                    channels: a.channels,
                    sample_rate: a.sample_rate,
                },
                codec_id: final_codec,
                language: a.language.clone(),
                bitrate: Some(a.bitrate),
                transcode_to,
            });
        }

        // Subtitle tracks
        for s in &index.subtitle_streams {
            tracks.push(TrackInfo {
                id: format!("s/{}", s.stream_index),
                track_type: TrackType::Subtitle {
                    format: format!("{:?}", s.format),
                },
                codec_id: format!("{:?}", s.codec_id),
                language: s.language.clone(),
                bitrate: None,
                transcode_to: None,
            });
        }

        let file_size = std::fs::metadata(path).map(|m| m.len()).unwrap_or(0);

        Self {
            file_size,
            duration_secs: index.duration_secs,
            video_timebase: index.video_timebase,
            tracks,
            index,
            cache_enabled: cache,
        }
    }
}
