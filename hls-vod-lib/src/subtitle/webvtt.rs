#![allow(dead_code)]

//! WebVTT format writer
//!
//! Generates WebVTT formatted output for HLS subtitle segments.

use crate::subtitle::extractor::SubtitleCue;
use bytes::Bytes;

/// WebVTT writer configuration
#[derive(Debug, Clone)]
#[derive(Default)]
pub struct WebVttConfig {
    /// Include WebVTT header comment
    pub include_header_comment: bool,
}


/// WebVTT writer for generating subtitle segments
pub struct WebVttWriter {
    config: WebVttConfig,
    output: String,
}

impl WebVttWriter {
    /// Create a new WebVTT writer
    pub fn new() -> Self {
        Self::with_config(WebVttConfig::default())
    }

    /// Create a new WebVTT writer with custom configuration
    pub fn with_config(config: WebVttConfig) -> Self {
        Self {
            config,
            output: String::new(),
        }
    }

    /// Write WebVTT header
    fn write_header(&mut self) {
        self.output.push_str("WEBVTT\n");

        if self.config.include_header_comment {
            self.output.push_str("\nGenerated by HLS Server\n");
        }

        self.output.push('\n');
    }

    /// Format a timestamp as WebVTT time (HH:MM:SS.mmm)
    pub fn format_timestamp(ms: i64) -> String {
        let total_ms = ms.max(0) as u64;
        let hours = total_ms / 3_600_000;
        let minutes = (total_ms % 3_600_000) / 60_000;
        let seconds = (total_ms % 60_000) / 1000;
        let millis = total_ms % 1000;
        format!("{:02}:{:02}:{:02}.{:03}", hours, minutes, seconds, millis)
    }

    /// Escape HTML entities in text for WebVTT
    pub fn escape_html(text: &str) -> String {
        text.replace('&', "&amp;")
            .replace('<', "&lt;")
            .replace('>', "&gt;")
            .replace('"', "&quot;")
    }

    /// Write a single cue
    fn write_cue(&mut self, cue: &SubtitleCue) {
        // Write timing line
        let start = Self::format_timestamp(cue.start_ms);
        let end = Self::format_timestamp(cue.end_ms);
        self.output.push_str(&format!("{} --> {}\n", start, end));

        // Write text with HTML escaping
        let escaped_text = Self::escape_html(&cue.text);
        self.output.push_str(&escaped_text);
        self.output.push_str("\n\n");
    }

    /// Write multiple cues to WebVTT format
    pub fn write_cues(&mut self, cues: &[SubtitleCue]) {
        if self.output.is_empty() {
            self.write_header();
        }

        for cue in cues {
            self.write_cue(cue);
        }
    }

    /// Write cues and get the result as bytes
    pub fn write(&mut self, cues: &[SubtitleCue]) -> Bytes {
        self.output.clear();
        self.write_cues(cues);
        Bytes::from(self.output.clone())
    }

    /// Get the current output
    pub fn output(&self) -> &str {
        &self.output
    }

    /// Clear the output buffer
    pub fn clear(&mut self) {
        self.output.clear();
    }
}

impl Default for WebVttWriter {
    fn default() -> Self {
        Self::new()
    }
}

/// Generate a WebVTT segment from subtitle cues
pub fn generate_webvtt_segment(cues: &[SubtitleCue], config: Option<WebVttConfig>) -> Bytes {
    let mut writer = match config {
        Some(cfg) => WebVttWriter::with_config(cfg),
        None => WebVttWriter::new(),
    };
    writer.write(cues)
}

/// Generate a WebVTT segment (MPEGTS offset is ignored now as requested)
pub fn generate_webvtt_with_timestamp_map(cues: &[SubtitleCue], _mpegts_offset: u64) -> Bytes {
    let config = WebVttConfig {
        include_header_comment: false,
    };
    generate_webvtt_segment(cues, Some(config))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_format_timestamp() {
        assert_eq!(WebVttWriter::format_timestamp(0), "00:00:00.000");
        assert_eq!(WebVttWriter::format_timestamp(1000), "00:00:01.000");
        assert_eq!(WebVttWriter::format_timestamp(61000), "00:01:01.000");
        assert_eq!(WebVttWriter::format_timestamp(3661000), "01:01:01.000");
        assert_eq!(WebVttWriter::format_timestamp(-1000), "00:00:00.000");
    }

    #[test]
    fn test_escape_html() {
        assert_eq!(WebVttWriter::escape_html("Hello"), "Hello");
        assert_eq!(WebVttWriter::escape_html("A & B"), "A &amp; B");
        assert_eq!(WebVttWriter::escape_html("A < B"), "A &lt; B");
        assert_eq!(WebVttWriter::escape_html("A > B"), "A &gt; B");
        assert_eq!(
            WebVttWriter::escape_html("Say \"Hi\""),
            "Say &quot;Hi&quot;"
        );
        assert_eq!(WebVttWriter::escape_html("<tag>"), "&lt;tag&gt;");
    }

    #[test]
    fn test_webvtt_writer_creation() {
        let writer = WebVttWriter::new();
        assert!(writer.output().is_empty());
    }

    #[test]
    fn test_webvtt_writer_with_config() {
        let config = WebVttConfig {
            include_header_comment: false,
        };
        let writer = WebVttWriter::with_config(config);
        assert!(writer.output().is_empty());
    }

    #[test]
    fn test_write_single_cue() {
        let mut writer = WebVttWriter::new();
        let cue = SubtitleCue::new(1000, 3000, "Hello World".to_string());
        writer.write_cues(&[cue]);

        let output = writer.output();
        assert!(output.contains("WEBVTT"));
        assert!(!output.contains("X-TIMESTAMP-MAP"));
        assert!(output.contains("00:00:01.000 --> 00:00:03.000"));
        assert!(output.contains("Hello World"));
    }

    #[test]
    fn test_write_multiple_cues() {
        let mut writer = WebVttWriter::new();
        let cues = vec![
            SubtitleCue::new(1000, 2000, "First".to_string()),
            SubtitleCue::new(3000, 4000, "Second".to_string()),
        ];
        writer.write_cues(&cues);

        let output = writer.output();
        assert!(!output.contains("1\n"));
        assert!(!output.contains("2\n"));
        assert!(output.contains("First"));
        assert!(output.contains("Second"));
    }

    #[test]
    fn test_generate_webvtt_segment() {
        let cues = vec![SubtitleCue::new(0, 2000, "Test".to_string())];
        let result = generate_webvtt_segment(&cues, None);
        assert!(!result.is_empty());
        let text = String::from_utf8_lossy(&result);
        assert!(text.contains("WEBVTT"));
    }

    #[test]
    fn test_generate_with_timestamp_map() {
        let cues = vec![SubtitleCue::new(0, 2000, "Test".to_string())];
        let result = generate_webvtt_with_timestamp_map(&cues, 1000000);
        let text = String::from_utf8_lossy(&result);
        assert!(!text.contains("X-TIMESTAMP-MAP"));
    }
}
